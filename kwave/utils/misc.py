from datetime import datetime
from typing import Union
import scipy

import numpy as np


def get_date_string():
    return datetime.now().strftime("%d-%b-%Y-%H-%M-%S")


def gaussian(x, magnitude=None, mean=0, variance=1):
    if magnitude is None:
        magnitude = np.sqrt(2 * np.pi * variance)
    return magnitude * np.exp(-(x - mean) ** 2 / (2 * variance))


def ndgrid(*args):
    return np.array(np.meshgrid(*args, indexing='ij'))


def sinc(x):
    return np.sinc(x / np.pi)


def round_even(x):
    """
    Rounds to the nearest even integer.

    Args:
        x (float): inpput value

    Returns:
        (int): nearest odd integer.
    """
    return 2 * round(x / 2)


def round_odd(x):
    """
    Rounds to the nearest odd integer.

    Args:
        x (float): input value

    Returns:
        (int): nearest odd integer.

    """
    return 2 * round((x + 1) / 2) - 1


def focused_bowl_oneil(radius: float, diameter: float, velocity: float, frequency: float, sound_speed: float,
                       density: float, axial_positions: Union[np.array, float, list] = None,
                       lateral_positions: Union[np.array, float, list] = None) -> [float, float]:
    """
    focused_bowl_oneil calculates O'Neil's solution (O'Neil, H. Theory of
    focusing radiators. J. Acoust. Soc. Am., 21(5), 516-526, 1949) for
    the axial and lateral pressure amplitude generated by a focused bowl
    transducer when uniformly driven by a continuous wave sinusoid at a
    given frequency and normal surface velocity.

    The solution is evaluated at the positions along the beam axis given
    by axial_position (where 0 corresponds to the transducer surface),
    and lateral positions through the geometric focus given by
    lateral_position (where 0 corresponds to the beam axis). To return
    only the axial or lateral pressure, set the either axial_position or
    lateral_position to [].

    Note, O'Neil's formulae are derived under the assumptions of the
    Rayleigh integral, which are valid when the transducer diameter is
    large compared to both the transducer height and the acoustic
    wavelength.

    Args:
        radius:
        diameter:
        velocity:
        frequency:
        sound_speed:
        density:
        axial_positions:
        lateral_positions:

    Example:
        # define transducer parameters
        radius = 140e-3  # [m]
        diameter = 120e-3  # [m]
        velocity = 100e-3  # [m / s]
        frequency = 1e6  # [Hz]
        sound_speed = 1500  # [m / s]
        density = 1000  # [kg / m ^ 3]

        # define position vectors
        axial_position = np.arange(0, 250e-3 + 1e-4, 1e-4)  # [m]
        lateral_position = np.arange(-15e-3, 15e-3 + 1e-4, 1e-4)  # [m]

        # evaluate pressure
        [p_axial, p_lateral] = focused_bowl_oneil(radius, diameter,
                                                  velocity, frequency, sound_speed, density,
                                                  axial_position, lateral_position)
    Returns:
         p_axial:           pressure amplitude at the axial_position [Pa]
         p_lateral:         pressure amplitude at the lateral_position [Pa]
    """
    float_eps = np.finfo(float).eps

    def calculate_axial_pressure() -> float:
        # calculate distances
        B = np.sqrt((axial_positions - h) ** 2 + (diameter / 2) ** 2)
        d = B - axial_positions
        E = 2 / (1 - axial_positions / radius)

        # compute pressure
        P = E * np.sin(k * d / 2)

        # replace values where axial_position is equal to the radius with limit
        P[np.abs(axial_positions - radius) < float_eps] = k * h

        # calculate magnitude of the on - axis pressure
        axial_pressure = density * sound_speed * velocity * np.abs(P)
        return axial_pressure

    def calculate_lateral_pressure() -> float:
        # calculate magnitude of the lateral pressure at the geometric focus
        Z = k * lateral_positions * diameter / (2 * radius)
        lateral_pressure = 2. * density * sound_speed * velocity * k * h * scipy.special.jv(1, Z) / Z

        # replace origin with limit
        lateral_pressure[lateral_positions == 0] = density * sound_speed * velocity * k * h
        return lateral_pressure

    # wave number
    k = 2 * np.pi * frequency / sound_speed

    # height of rim
    h = radius - np.sqrt(radius ** 2 - (diameter / 2) ** 2)

    p_axial = None
    p_lateral = None

    if lateral_positions is not None:
        p_lateral = calculate_lateral_pressure()
    if axial_positions is not None:
        p_axial = calculate_axial_pressure()

    return p_axial, p_lateral

    return [p_axial, p_lateral]


def find_closest(A, a):
    """
    find_closest returns the value and index of the item in A that is
    closest to the value a. For vectors, value and index correspond to
    the closest element in A. For matrices, value and index are row
    vectors corresponding to the closest element from each column. For
    N-D arrays, the function finds the closest value along the first
    matrix dimension (singleton dimensions are removed before the
    search). If there is more than one element with the closest value,
    the index of the first one is returned.

    Args:
        A: matrix to search
        a: value to find

    Returns:
        val
        idx
    """

    assert isinstance(A, np.ndarray), "A must be an np.array"

    idx = np.unravel_index(np.argmin(abs(A - a)), A.shape)
    return A[idx], idx
